# ü§ñ Automated GitHub Copilot Code Review & Quality Automation
#
# This workflow provides comprehensive automated code review and quality assurance
# for the AnimeBOX React Native application. It runs on every pull request to
# ensure code quality, consistency, and adherence to project standards.
#
# Key Features:
# - Automatic Copilot reviewer assignment
# - Comprehensive code analysis (TypeScript, React Native, Performance, etc.)
# - PR template compliance validation
# - Mobile-specific best practices checking
# - Documentation coverage analysis
# - Automated quality scoring and feedback
# - Quality Gate that blocks merging when issues are found
#
# Workflow triggers on: pull_request [opened, synchronize, reopened]
# Target branches: develop, main
# Excludes: dependabot[bot], github-copilot[bot]

name: ü§ñ Copilot Review & Quality Automation

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [develop, main]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  copilot-automation:
    name: ü§ñ Copilot Review & Quality Checks
    runs-on: ubuntu-latest
    timeout-minutes: 5
    if: github.actor != 'dependabot[bot]' && github.actor != 'github-copilot[bot]'

    steps:
      - name: ü§ñ Auto-request Copilot as reviewer
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const pull_number = context.payload.pull_request.number;

            try {
              // Check if Copilot is already a reviewer to avoid duplicate requests
              const { data: reviews } = await github.rest.pulls.listRequestedReviewers({
                owner,
                repo,
                pull_number
              });

              const copilotAlreadyRequested = reviews.users.some(user =>
                user.login === 'github-copilot' || user.login === 'copilot'
              );

              if (!copilotAlreadyRequested) {
                // Request Copilot as reviewer for automated code review
                await github.rest.pulls.requestReviewers({
                  owner,
                  repo,
                  pull_number,
                  reviewers: ['github-copilot']
                });

                // Success: Copilot reviewer successfully requested
                core.info('‚úÖ Successfully requested Copilot as reviewer');

                // Add informational comment to PR about automated Copilot review
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pull_number,
                  body: `ü§ñ **Copilot has been automatically requested as a reviewer**\n\nCopilot will review this PR based on our project standards and guidelines defined in \`.github/copilot-instructions.md\`.\n\n---\n*This is an automated action. Copilot reviews help maintain code quality and consistency.*`
                });

              } else {
                // Info: Copilot already assigned, skipping duplicate request
                core.info('‚ÑπÔ∏è Copilot is already requested as a reviewer');
              }

            } catch (error) {
              // Error: Failed to request Copilot reviewer - log for debugging
              core.error('Error requesting Copilot reviewer: ' + error.message);

              // Fallback: Add explanatory comment when automatic reviewer assignment fails
              try {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pull_number,
                  body: `ü§ñ **Copilot Auto-Review Setup**\n\nTo enable automatic Copilot reviews:\n\n1. Go to Repository Settings ‚Üí General ‚Üí Pull Requests\n2. Enable "Automatically request reviews from owners of the code being changed"\n3. Or manually request \`@github-copilot\` as a reviewer\n\n---\n*Copilot reviews are configured via \`.github/copilot-instructions.md\`*`
                });
              } catch (commentError) {
                // Error: Failed to add fallback comment - log for debugging
                core.error('Error adding fallback comment: ' + commentError.message);
              }
            }

      # This step analyzes PR changes and categorizes files to provide context
      # for reviewers about the scope and impact of the changes made
      - name: üìä Log PR Changes (Info Only)
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Retrieve repository and PR context from GitHub Actions
            const { owner, repo } = context.repo;
            const pull_number = context.payload.pull_request.number;

            try {
              // Get changed files for logging
              const { data: files } = await github.rest.pulls.listFiles({
                owner,
                repo,
                pull_number
              });

              const categories = {
                architecture: [],
                components: [],
                database: [],
                utilities: [],
                tests: [],
                documentation: [],
                github: []
              };

              // Categorize changes for logging
              for (const file of files) {
                if (file.filename.startsWith('app/')) {
                  categories.architecture.push(file.filename);
                } else if (file.filename.startsWith('components/')) {
                  categories.components.push(file.filename);
                } else if (file.filename.startsWith('db/')) {
                  categories.database.push(file.filename);
                } else if (file.filename.startsWith('helpers/')) {
                  categories.utilities.push(file.filename);
                } else if (file.filename.includes('test') || file.filename.includes('__tests__')) {
                  categories.tests.push(file.filename);
                } else if (file.filename.endsWith('.md')) {
                  categories.documentation.push(file.filename);
                } else if (file.filename.includes('.github/')) {
                  categories.github.push(file.filename);
                }
              }

              // Log PR change analysis results for debugging
              core.info('üìä PR Change Categories:');
              Object.entries(categories).forEach(([category, files]) => {
                if (files.length > 0) {
                  core.info(`  ${category}: ${files.length} file(s)`);
                }
              });

            } catch (error) {
              // Error: Failed to analyze PR changes - log for debugging
              core.error('Error analyzing PR changes: ' + error.message);
            }

      # This step validates PR template compliance to ensure all required
      # sections are filled out properly for effective code reviews
      - name: üìã PR Template Compliance Check
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const pull_number = context.payload.pull_request.number;

            try {
              const { data: pr } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number
              });

              const body = pr.body || '';
              const title = pr.title || '';

              // Check PR template compliance
              const templateChecks = {
                hasDescription: body.includes('## üìã Description') || body.includes('Description'),
                hasTypeOfChange: body.includes('## üìÑ Type of Change') || body.includes('Type of Change'),
                hasTesting: body.includes('## üß™ Testing') || body.includes('Testing'),
                hasChecklist: body.includes('## ‚úÖ Checklist') || body.includes('Checklist'),
                hasCheckboxes: body.includes('- [ ]') || body.includes('- [x]'),
                hasProperTitle: title.length > 10 && !title.includes('WIP') && !title.includes('Draft')
              };

              const complianceScore = Object.values(templateChecks).filter(Boolean).length;
              const totalChecks = Object.keys(templateChecks).length;

              // Log PR template compliance results for debugging
              core.info('üìã PR Template Compliance:');
              core.info(`  Score: ${complianceScore}/${totalChecks}`);
              Object.entries(templateChecks).forEach(([check, passed]) => {
                core.info(`  ${check}: ${passed ? '‚úÖ' : '‚ùå'}`);
              });

              // Store compliance data for later use in automated analysis
              const complianceData = {
                score: complianceScore,
                total: totalChecks,
                percentage: Math.round((complianceScore / totalChecks) * 100),
                checks: templateChecks
              };

              // Add compliance comment if score is low
              if (complianceScore < 4) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: pull_number,
                  body: `## üìã PR Template Compliance Alert

                  **Compliance Score: ${complianceScore}/${totalChecks} (${complianceData.percentage}%)**

                  Missing sections:
                  ${Object.entries(templateChecks)
                    .filter(([_, passed]) => !passed)
                    .map(([check, _]) => `- ${check.replace(/([A-Z])/g, ' $1').toLowerCase()}`)
                    .join('\n')}

                  Please update your PR description to include all required sections from the template for better review quality.

                  ---
                  *This helps reviewers understand your changes better and ensures consistent PR quality.*`
                });
              }

            } catch (error) {
              // Error: Failed to check PR template compliance - log for debugging
              core.error('Error checking PR template compliance: ' + error.message);
            }

      - name: üî• Checkout code for quality checks
        uses: actions/checkout@v4

      - name: üîß Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "18"
          cache: "yarn"

      # Install project dependencies using Yarn Berry for consistent builds
      - name: üì¶ Install dependencies
        run: yarn install --immutable

      # Validate TypeScript compilation to ensure type safety across the codebase
      - name: üîç TypeScript Check
        run: |
          echo "üîç Running TypeScript compilation check..."
          yarn type-check
          echo "‚úÖ TypeScript check passed"

      # Run ESLint to ensure code quality and consistency with project standards
      - name: üé® ESLint Check
        run: |
          echo "üé® Running ESLint..."
          yarn lint
          echo "‚úÖ ESLint check passed"

      # Execute comprehensive test suite with coverage reporting
      - name: üß™ Test Suite
        id: test-suite
        run: |
          echo "üß™ Running test suite..."
          yarn test --coverage --watchAll=false 2>&1 | tee test-output.log

          # Extract test count from Jest output
          TEST_RESULTS=$(grep -E "Tests:|Test Suites:" test-output.log | tail -2)
          PASSED_TESTS=$(echo "$TEST_RESULTS" | grep "Tests:" | grep -o '[0-9]* passed' | head -1)
          TOTAL_TESTS=$(echo "$TEST_RESULTS" | grep "Tests:" | grep -o '[0-9]* total' | head -1)

          echo "test-summary=$PASSED_TESTS, $TOTAL_TESTS" >> $GITHUB_OUTPUT
          echo "‚úÖ All tests passed"

      # Validate markdown documentation files for consistency and correctness
      - name: üìù Markdown Lint Check
        run: |
          echo "üìù Checking markdown documentation..."
          if ls docs/**/*.md .github/**/*.md 1> /dev/null 2>&1; then
            yarn markdownlint docs/**/*.md .github/**/*.md
            echo "‚úÖ Markdown linting passed"
          else
            echo "‚ÑπÔ∏è No markdown files to check"
          fi

      # Comprehensive automated code analysis including TypeScript, React Native,
      # performance, testing, documentation, and architectural best practices
      - name: üîç Automated Code Analysis
        uses: actions/github-script@v7
        id: code-analysis
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Initialize repository and PR context for comprehensive analysis
            const { owner, repo } = context.repo;
            const pull_number = context.payload.pull_request.number;

            // Get PR data and files
            const { data: pr } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number
            });

            const { data: files } = await github.rest.pulls.listFiles({
              owner,
              repo,
              pull_number
            });

            // Initialize analysis results
            const analysis = {
              typeScript: { passed: [], failed: [] },
              reactNative: { passed: [], failed: [] },
              drizzleORM: { passed: [], failed: [] },
              testing: { passed: [], failed: [] },
              performance: { passed: [], failed: [] },
              documentation: { passed: [], failed: [] },
              architecture: { passed: [], failed: [] },
              commonIssues: { passed: [], failed: [] },
              mobileSpecific: { passed: [], failed: [] }
            };

            // Analyze each changed file
            for (const file of files) {
              if (file.status === 'removed') continue;

              try {
                // Get file content for analysis
                const { data: fileData } = await github.rest.repos.getContent({
                  owner,
                  repo,
                  path: file.filename,
                  ref: pr.head.sha
                });

                const content = Buffer.from(fileData.content, 'base64').toString('utf8');
                const isTypeScript = file.filename.endsWith('.ts') || file.filename.endsWith('.tsx');
                const isComponent = file.filename.startsWith('components/') || file.filename.startsWith('app/');
                const isDatabase = file.filename.startsWith('db/');
                const isTest = file.filename.includes('test') || file.filename.includes('__tests__');

                // TypeScript Analysis
                if (isTypeScript) {
                  // Check for 'any' types
                  if (content.includes(': any') || content.includes('any[]') || content.includes('any>')) {
                    analysis.typeScript.failed.push(`${file.filename}: Contains 'any' types`);
                  } else {
                    analysis.typeScript.passed.push(`${file.filename}: No 'any' types found`);
                  }

                  // Check for proper interfaces/types
                  if (content.includes('interface ') || content.includes('type ') || content.includes('enum ')) {
                    analysis.typeScript.passed.push(`${file.filename}: Uses proper TypeScript definitions`);
                  }
                }

                // React Native Analysis
                if (isComponent) {
                  // Check for StyleSheet usage
                  if (content.includes('StyleSheet.create')) {
                    analysis.reactNative.passed.push(`${file.filename}: Uses StyleSheet.create`);
                  } else if (content.includes('style={{') || content.includes('style={[')) {
                    analysis.reactNative.failed.push(`${file.filename}: Uses inline styles instead of StyleSheet`);
                  }

                  // Check for responsive design
                  if (content.includes('moderateScale') || content.includes('scale') || content.includes('verticalScale')) {
                    analysis.reactNative.passed.push(`${file.filename}: Uses react-native-size-matters for responsive design`);
                  }

                  // Check for accessibility
                  if (content.includes('accessibilityLabel') || content.includes('accessibilityHint')) {
                    analysis.mobileSpecific.passed.push(`${file.filename}: Includes accessibility labels`);
                  } else if (content.includes('<TouchableOpacity') || content.includes('<Pressable') || content.includes('<Button')) {
                    analysis.mobileSpecific.failed.push(`${file.filename}: Interactive elements missing accessibility labels`);
                  }

                  // Check for web-only CSS
                  const webOnlyProps = ['cursor:', 'user-select:', 'box-shadow:', 'outline:'];
                  const foundWebProps = webOnlyProps.filter(prop => content.includes(prop));
                  if (foundWebProps.length > 0) {
                    analysis.mobileSpecific.failed.push(`${file.filename}: Contains web-only CSS properties: ${foundWebProps.join(', ')}`);
                  }
                }

                // Database Analysis
                if (isDatabase) {
                  // Check for Drizzle queries
                  if (content.includes('useLiveQuery') || content.includes('db.select') || content.includes('db.insert')) {
                    analysis.drizzleORM.passed.push(`${file.filename}: Uses type-safe Drizzle operations`);
                  }

                  // Check for proper schema definitions
                  if (content.includes('sqliteTable') || content.includes('text()') || content.includes('integer()')) {
                    analysis.drizzleORM.passed.push(`${file.filename}: Proper Drizzle schema definition`);
                  }
                }

                // Testing Analysis
                if (isTest) {
                  analysis.testing.passed.push(`${file.filename}: Test file present`);

                  if (content.includes('describe(') && content.includes('it(')) {
                    analysis.testing.passed.push(`${file.filename}: Proper test structure`);
                  }
                }

                // Common Issues Check (skip for workflow files)
                const isWorkflowFile = file.filename.startsWith('.github/workflows/');

                if (!isWorkflowFile) {
                  if (content.includes('console.log') || content.includes('console.error') || content.includes('console.warn')) {
                    analysis.commonIssues.failed.push(`${file.filename}: Contains console statements (should use core.info/core.error/core.warning)`);
                  } else {
                    analysis.commonIssues.passed.push(`${file.filename}: No console statements`);
                  }

                  // Check for hardcoded strings (skip for workflow files and config files)
                  const isConfigFile = file.filename.endsWith('.json') || file.filename.endsWith('.yml') || file.filename.endsWith('.yaml') || file.filename.endsWith('.md');

                  if (!isConfigFile) {
                    const hardcodedStrings = content.match(/"[^"]{20,}"/g) || [];
                    if (hardcodedStrings.length > 0) {
                      analysis.commonIssues.failed.push(`${file.filename}: Contains potential hardcoded strings`);
                    }
                  }
                } else {
                  analysis.commonIssues.passed.push(`${file.filename}: Workflow file - skipping console and hardcoded string checks`);
                }

                // Performance checks
                if (content.includes('useMemo') || content.includes('useCallback')) {
                  analysis.performance.passed.push(`${file.filename}: Uses performance optimization hooks`);
                }

                // Documentation checks
                const commentLines = content.split('\n').filter(line =>
                  line.trim().startsWith('//') || line.trim().startsWith('/*') || line.trim().startsWith('*')
                ).length;
                const codeLines = content.split('\n').filter(line =>
                  line.trim() && !line.trim().startsWith('//') && !line.trim().startsWith('/*') && !line.trim().startsWith('*')
                ).length;

                if (commentLines / Math.max(codeLines, 1) > 0.1) {
                  analysis.documentation.passed.push(`${file.filename}: Well documented (${commentLines} comment lines)`);
                } else if (codeLines > 50) {
                  analysis.documentation.failed.push(`${file.filename}: Needs more documentation (${commentLines} comments for ${codeLines} code lines)`);
                }

                // Architecture checks
                const properPaths = {
                  'components/': isComponent,
                  'app/': file.filename.startsWith('app/'),
                  'db/': file.filename.startsWith('db/'),
                  'helpers/': file.filename.startsWith('helpers/'),
                  'hooks/': file.filename.startsWith('hooks/')
                };

                if (Object.values(properPaths).some(Boolean)) {
                  analysis.architecture.passed.push(`${file.filename}: Follows project structure`);
                }

              } catch (error) {
                // Error: Failed to analyze individual file - log for debugging
                core.error(`Error analyzing ${file.filename}: ${error.message}`);
              }
            }

            // Check if tests exist for new functionality
            const hasNewCode = files.some(f => f.status === 'added' && (f.filename.endsWith('.ts') || f.filename.endsWith('.tsx')));
            const hasNewTests = files.some(f => f.status === 'added' && (f.filename.includes('test') || f.filename.includes('__tests__')));

            if (hasNewCode && !hasNewTests) {
              analysis.testing.failed.push('New functionality added without corresponding tests');
            } else if (hasNewCode && hasNewTests) {
              analysis.testing.passed.push('New functionality includes tests');
            }

            // Store analysis results for next step
            const analysisResults = JSON.stringify(analysis);
            return { analysis };

      - name: üìä Quality Gate Summary
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const pull_number = context.payload.pull_request.number;

            // Get test results and analysis from previous steps
            const testSummary = `${{ steps.test-suite.outputs.test-summary }}` || 'tests completed';
            const analysis = ${{ steps.code-analysis.outputs.result }}.analysis;

            // Get changed files for context
            const { data: files } = await github.rest.pulls.listFiles({
              owner,
              repo,
              pull_number
            });

            const hasTypeScriptChanges = files.some(f => f.filename.endsWith('.ts') || f.filename.endsWith('.tsx'));
            const hasComponentChanges = files.some(f => f.filename.startsWith('components/'));
            const hasDbChanges = files.some(f => f.filename.startsWith('db/'));
            const hasTestChanges = files.some(f => f.filename.includes('test') || f.filename.includes('__tests__'));
            const hasAppChanges = files.some(f => f.filename.startsWith('app/'));

            const summaryComment = `## ‚úÖ Automated Quality Gate Results

            All quality checks have passed successfully:

            - üîç **TypeScript Compilation**: ‚úÖ Passed
            - üé® **ESLint Code Style**: ‚úÖ Passed
            - üß™ **Test Suite**: ‚úÖ Passed (${testSummary})
            - üìù **Markdown Documentation**: ‚úÖ Passed

            ### ü§ñ Copilot Review Status
            - **Reviewer**: Copilot has been automatically requested
            - **Guidelines**: Following [project standards](.github/copilot-instructions.md)
            - **Focus Areas**: React Native, TypeScript, Drizzle ORM best practices

            ---
            *This PR meets all technical quality standards and is ready for human review.*`;

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: pull_number,
              body: summaryComment
            });

            // Helper function to format analysis results
            const formatAnalysisSection = (sectionName, data, emoji) => {
              if (data.passed.length === 0 && data.failed.length === 0) return '';

              const passedItems = data.passed.map(item => `  ‚úÖ ${item}`).join('\n');
              const failedItems = data.failed.map(item => `  ‚ùå ${item}`).join('\n');
              const status = data.failed.length === 0 ? '‚úÖ' : '‚ùå';

              return `${emoji} **${sectionName}**: ${status} ${data.failed.length === 0 ? 'All checks passed' : `${data.failed.length} issue(s) found`}
            ${passedItems}${passedItems && failedItems ? '\n' : ''}${failedItems}
            `;
            };

            // Generate detailed analysis report
            const detailedAnalysis = `## üîç Automated Code Review Analysis

            ### üìã Review Checklist Results

            ${formatAnalysisSection('TypeScript', analysis.typeScript, 'üî∑')}
            ${formatAnalysisSection('React Native', analysis.reactNative, 'üì±')}
            ${formatAnalysisSection('Drizzle ORM', analysis.drizzleORM, 'üóÑÔ∏è')}
            ${formatAnalysisSection('Testing', analysis.testing, 'üß™')}
            ${formatAnalysisSection('Performance', analysis.performance, '‚ö°')}
            ${formatAnalysisSection('Documentation', analysis.documentation, 'üìö')}
            ${formatAnalysisSection('Architecture', analysis.architecture, 'üèóÔ∏è')}

            ### üö® Issues Flagged

            ${formatAnalysisSection('Common Issues', analysis.commonIssues, '‚ö†Ô∏è')}

            ### üì± Mobile Specific Checks

            ${formatAnalysisSection('Mobile Compatibility', analysis.mobileSpecific, 'üì±')}

            ### üéØ Summary
            - **Total Files Analyzed**: ${files.length}
            - **Issues Found**: ${Object.values(analysis).reduce((total, section) => total + section.failed.length, 0)}
            - **Best Practices Followed**: ${Object.values(analysis).reduce((total, section) => total + section.passed.length, 0)}

            ${Object.values(analysis).some(section => section.failed.length > 0) ?
              '### üîß Action Required\nPlease address the flagged issues above before merging.' :
              '### ‚úÖ Ready for Review\nAll automated checks passed! This PR follows project standards.'}

            ---
            *Automated analysis based on [AnimeBOX Project Guidelines](.github/copilot-instructions.md)*`;

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: pull_number,
              body: detailedAnalysis
            });

            // Enhanced Copilot Review Guidance with analysis context
            const analysisContext = Object.values(analysis).some(section => section.failed.length > 0) ?
              'ATTENTION: Automated analysis found issues that need review.' :
              'Good news: Automated analysis shows this PR follows most best practices.';

            const reviewGuidance = `## ü§ñ @github-copilot - Enhanced Review Guidance

            **Analysis Context**: ${analysisContext}

            Please provide a comprehensive review focusing on the areas flagged by our automated analysis:

            ### üìã Priority Review Areas
            ${hasTypeScriptChanges ? `- **TypeScript Changes**: ${analysis.typeScript.failed.length > 0 ? `‚ö†Ô∏è ${analysis.typeScript.failed.length} issue(s) detected` : '‚úÖ No issues detected'}\n` : ''}${hasComponentChanges || hasAppChanges ? `- **React Native Components**: ${analysis.reactNative.failed.length > 0 ? `‚ö†Ô∏è ${analysis.reactNative.failed.length} issue(s) detected` : '‚úÖ No issues detected'}\n` : ''}${hasDbChanges ? `- **Database Changes**: ${analysis.drizzleORM.failed.length > 0 ? `‚ö†Ô∏è ${analysis.drizzleORM.failed.length} issue(s) detected` : '‚úÖ No issues detected'}\n` : ''}${hasTestChanges ? `- **Testing**: ${analysis.testing.failed.length > 0 ? `‚ö†Ô∏è ${analysis.testing.failed.length} issue(s) detected` : '‚úÖ Tests look good'}\n` : ''}
            ### üéØ Focus Your Review On:
            1. **Validate Flagged Issues**: Confirm if the ${Object.values(analysis).reduce((total, section) => total + section.failed.length, 0)} flagged issues are genuine concerns
            2. **Code Quality**: Look beyond automated checks for logic, readability, and maintainability
            3. **Security**: Check for potential security vulnerabilities not caught by static analysis
            4. **Business Logic**: Ensure the implementation meets requirements correctly
            5. **Edge Cases**: Consider scenarios that automated testing might miss

            ### üìä Automated Analysis Summary:
            - ‚úÖ **Passed Checks**: ${Object.values(analysis).reduce((total, section) => total + section.passed.length, 0)}
            - ‚ùå **Failed Checks**: ${Object.values(analysis).reduce((total, section) => total + section.failed.length, 0)}
            - üìÑ **Files Analyzed**: ${files.length}

            ### üîç Review Guidelines:
            - If automated analysis flagged an issue, please validate and provide specific feedback
            - For issues not flagged, still review for correctness and best practices
            - Consider the impact of changes on mobile performance and user experience
            - Verify that new functionality includes appropriate error handling

            ---
            *This enhanced guidance is based on automated analysis results and [AnimeBOX Project Guidelines](.github/copilot-instructions.md)*`;

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: pull_number,
              body: reviewGuidance
            });

      # Quality Gate: Block merge if issues are found
      - name: üö´ Quality Gate - Block Merge on Issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const analysis = ${{ steps.code-analysis.outputs.result }}.analysis;

            // Count total issues found
            const totalIssues = Object.values(analysis).reduce((total, section) => total + section.failed.length, 0);
            const totalPassed = Object.values(analysis).reduce((total, section) => total + section.passed.length, 0);

            // Log summary for transparency
            core.info(`üîç Quality Gate Summary:`);
            core.info(`  ‚úÖ Passed Checks: ${totalPassed}`);
            core.info(`  ‚ùå Failed Checks: ${totalIssues}`);

            if (totalIssues > 0) {
              // List the specific issues found
              core.info(`üö® Issues preventing merge:`);
              Object.entries(analysis).forEach(([category, data]) => {
                if (data.failed.length > 0) {
                  core.info(`  ${category}:`);
                  data.failed.forEach(issue => core.info(`    - ${issue}`));
                }
              });

              // Create a status check that will block the merge
              const { owner, repo } = context.repo;
              const pull_number = context.payload.pull_request.number;
              const { data: pr } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number
              });

              // Add blocking comment
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pull_number,
                body: `## üö´ **MERGE BLOCKED - Quality Gate Failed**

                **${totalIssues} issue(s) must be resolved before this PR can be merged.**

                ### üîß Required Actions:
                ${Object.entries(analysis)
                  .filter(([_, data]) => data.failed.length > 0)
                  .map(([category, data]) =>
                    `**${category}:**\n${data.failed.map(issue => `- ${issue}`).join('\n')}`
                  ).join('\n\n')}

                ### ‚úÖ Next Steps:
                1. Fix the issues listed above
                2. Push your changes to trigger a new analysis
                3. Once all issues are resolved, this check will pass automatically

                ---
                *This PR will remain blocked until all automated quality checks pass.*`
              });

              // Fail the workflow to prevent merge
              core.setFailed(`Quality Gate Failed: ${totalIssues} issue(s) found that must be resolved before merging.`);

            } else {
              core.info('üéâ Quality Gate Passed: No blocking issues found!');

              // Add success comment
              const { owner, repo } = context.repo;
              const pull_number = context.payload.pull_request.number;

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pull_number,
                body: `## üéâ **Quality Gate Passed!**

                All automated quality checks have passed successfully.

                ‚úÖ **${totalPassed} checks passed**
                ‚ùå **0 issues found**

                This PR meets all technical quality standards and is approved for merging.

                ---
                *Quality gate automatically validated by [AnimeBOX Project Guidelines](.github/copilot-instructions.md)*`
              });
            }
